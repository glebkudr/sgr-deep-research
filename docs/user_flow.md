ниже — два «сквозных» пользовательских сценария с явным указанием, какие подсистемы участвуют на каждом шаге. Формат: Шаг → Действие → Что видно в GUI → Какие подсистемы работают → Техническая деталь.

---

# Сценарий 1: Индексация выгрузки 1С

## Акторы и предусловия

* **Актор:** оператор (один пользователь), вошёл в GUI (JWT).
* **Есть:** локальная папка с выгрузкой 1С (`.bsl/.xml/.html/.txt`).
* **Запущено в Docker Compose:** `front (Next.js)`, `graphrag-api (FastAPI)`, `graphrag-indexer (Worker)`, `neo4j`, `redis`.

## Основной поток

**Шаг 1. Открыть страницу Upload/Index**

* **Действие:** оператор открывает `/upload`.
* **GUI:** форма: `Collection` (строка), селектор локальной папки/drag&drop файлов, кнопка «Индексировать».
* **Подсистемы:** `front`.
* **Тех.детаиль:** в `.env` фронта настроен `NEXT_PUBLIC_API_URL` на API.

**Шаг 2. Выбрать папку и задать коллекцию**

* **Действие:** указывает коллекцию (например, `erp_demo`) и выбирает папку с файлами.
* **GUI:** список отобранных файлов, общий размер, кнопка активна.
* **Подсистемы:** `front` (ограничения по расширениям).
* **Тех.детаиль:** большие наборы можно грузить батчами; либо фронт копирует в volume через API.

**Шаг 3. Запустить индексацию**

* **Действие:** жмёт «Индексировать».
* **GUI:** появляется карточка «Задача #<job_id>», статус `PENDING`.
* **Подсистемы:** `front → graphrag-api → redis`.
* **Тех.детаиль (API):** `POST /upload` → API сохраняет файлы в `WORKSPACE_DIR/<collection>/<job_id>/raw` и ставит джобу в Redis. Ответ `{ job_id }`.

**Шаг 4. Наблюдать прогресс**

* **Действие:** ничего не делает, страница сама поллит.
* **GUI:** статус меняется `PENDING → RUNNING`. Отображаются прогресс-бары:
  - Files processed: processed_files/total_files.
  - Embeddings: embedded_chunks/vector_chunks (появляется после чанкинга, растёт по мере эмбеддингов).
  - Graph nodes: graph_nodes_written/graph_nodes_total (при наличии totals; может «рывком» завершиться).
  - Graph edges: graph_edges_written/graph_edges_total (аналогично).
  - Спиннер «Идет индексирование…» показывается только если нет ни одного валидного знаменателя для прогресса текущей фазы.
* **Подсистемы:** `front (poll GET /jobs/{job_id}) → graphrag-api (читает статус) ← redis (хранит прогресс)`, параллельно `graphrag-indexer` работает.
* **Тех.детаиль (Worker пайплайн):**

  1. **Loaders**: рекурсивный обход `raw/`.
  2. **Extract 1C**: эвристики для BSL/метаданных (Routine, CALLS, READS_FROM/WRITES_TO, REFERENCES, HAS_*).
  3. **Chunking**: ~800 токенов, overlap ~120. Публикуется `vector_chunks`.
  4. **Embeddings (фаза EMBEDDING)**: OpenAI BYOK, по-батчевый прогресс — увеличивается `embedded_chunks` и сохраняется в Redis после каждого батча.
  5. **Graph writer (фаза GRAPH_WRITE)**: выставляются totals `graph_nodes_total/graph_edges_total`, при возможности инкрементируются `graph_*_written`, в минимальном варианте — при завершении записываются равными totals.
  6. **Vector index (фаза VECTOR_INDEX → FINALIZING)**: FAISS в `/app/indexes/<collection>/faiss` + маппинг `chunk_id ↔ node_id, path`.
  7. Фазы выставляются явно: `EMBEDDING → GRAPH_WRITE → VECTOR_INDEX → FINALIZING`.

**Шаг 5. Завершение индексации**

* **Действие:** дождаться статуса `DONE`.
* **GUI:** статус `DONE`, финальная статистика; кнопки «Повторить», «Открыть в Q&A».
* **Подсистемы:** `front`, `graphrag-api`, `redis`, `neo4j`, `faiss`.
* **Тех.детаиль:** при ошибках — статус `ERROR` и список `errors[]` с файлами/стеками.

## Альтернативы и ошибки

* **Неверные форматы:** API отклоняет, GUI помечает строки красным.
* **Ключ OpenAI отсутствует/невалиден:** задача падает, `ERROR: EMBEDDINGS_AUTH`; оператор правит `.env`, перезапускает.
* **Недостаточно памяти Neo4j:** задача замедляется или падает; увеличить heap/pagecache, перезапустить.

## Постусловия / приёмка

* В **Neo4j** есть узлы/связи доменной онтологии.
* В **FAISS** — индекс коллекции + маппинг чанков.
* Страница `/upload` показывает `DONE` и итоговую статистику. Во время индексации видны отдельные бары прогресса «Embeddings», «Graph nodes», «Graph edges» при наличии валидных знаменателей.
* В логах `graphrag-indexer` есть структурированные INFO-сообщения с ключами `event=... job_id=... collection=...`, в том числе:
  - `event=phase_set` при смене фаз (`EMBEDDING/GRAPH_WRITE/VECTOR_INDEX/FINALIZING`),
  - `event=embedding_progress` с `embedded_chunks/vector_chunks`,
  - `event=graph_write_completed` с `graph_*_written/graph_*_total`,
  - `event=vector_index_updated`,
  - `event=job_finished` с `duration_sec`.

---

# Сценарий 2: Ретривал «вопрос → ответ»

## Акторы и предусловия

* **Актор:** оператор (JWT).
* **Есть:** хотя бы одна коллекция в статусе `DONE` после индексации.
* **Запущено:** все сервисы как в сценарии 1.

## Основной поток

**Шаг 1. Открыть страницу Q&A**

* **Действие:** оператор открывает `/qa`.
* **GUI:** поле «Вопрос», селектор `Collection` (например, `erp_demo`), параметры `top_k`/`max_hops`, кнопка «Спросить».
* **Подсистемы:** `front`.

**Шаг 2. Задать вопрос**

* **Действие (пример):** «Где формируется движение по регистру `Продажи` при проведении документа `РеализацияТоваров`?»
* **GUI:** сообщение появляется в истории чата; рядом — индикатор стрима.
* **Подсистемы:** `front → graphrag-api`.

**Шаг 3. Гибридный ретривал**

* **Действие:** API обрабатывает запрос.
* **GUI:** в фоне — нет изменений, только стрим «Печатает…».
* **Подсистемы и шаги:**

  1. **Vector search** по FAISS (`top_k_v≈50`) → кандидаты чанков.
  2. **Seed extraction**: из чанков извлечь связанные доменные узлы (`Routine/Object/Register/...`) → `seed_ids`.
  3. **Graph expansion** в **Neo4j** на `max_hops` (по «сильным» связям: `CALLS, READS_FROM, WRITES_TO, REFERENCES, HAS_*`).
  4. **Context pack**: лучшие чанки + подграф (пути/узлы/ребра) + список использованных Cypher.
  5. **Strict LLM answer**: промпт (англ) с правилом «отвечай по-русски, только из предоставленного контекста; иначе — “Недостаточно данных в индексе.”».

**Шаг 4. Получить ответ**

* **GUI:** появляется потоковый ответ (текст). Ниже:

  * **Цитаты**: карточки с названием рутины/объекта, сниппетом и путём к файлу.
  * **Пути графа**: табличка откуда-куда (узел → тип связи → узел), 1–3 самых информативных пути.
* **Подсистемы:** `front (SSE) ← graphrag-api ← neo4j + faiss + openai`.

**Шаг 5. Навигация по источникам**

* **Действие:** оператор кликает цитату/путь.
* **GUI:** окошко со сниппетом кода/описания, ссылка на локальный путь (или просто показ файла/кусочка).
* **Подсистемы:** `front`.
* **Тех.детаиль:** путь берётся из маппинга `chunk_id ↔ path`; при желании можно добавить «копировать путь».

## Альтернативы и ошибки

* **Недостаточно контекста:** ответ «Недостаточно данных в индексе.» (ожидаемо).
* **Пустая коллекция / неверное имя:** 400 в API, GUI показывает тост с ошибкой.
* **LLM отказал (лимиты):** ретрай с экспоненциальной паузой (до 3 раз); если неудача — показать четкое сообщение.

## Постусловия / приёмка

* Ответ ≤ 4 сек p95 при `top_k=12, max_hops=2` на средних вопросах.
* Есть минимум 1–2 валидные цитаты и осмысленный короткий путь графа.
* При неподтверждённых фактах — строгий отказ.

---

## Что «под капотом» у каждого сценария (карта подсистем)

| Подсистема                    | Роль в Индексе                                  | Роль в Q&A                                                 |
| ----------------------------- | ----------------------------------------------- | ---------------------------------------------------------- |
| **Front (Next.js)**           | Загрузка, прогресс, статусы задач               | Поле вопроса, стрим ответа, цитаты, пути                   |
| **Auth (JWT)**                | Защита `/upload` и `/jobs/*`                    | Защита `/qa`                                               |
| **graphrag-api (FastAPI)**    | Приём файлов, постановка задач, выдача статусов | Гибридный ретривал, формирование контекста, вызов LLM, SSE |
| **Redis (Queue/State)**       | Очередь задач и прогресс                        | Необязателен (только для индексации)                       |
| **graphrag-indexer (Worker)** | Чанкинг, эмбеддинги, Neo4j upsert, FAISS build  | —                                                          |
| **Neo4j (Graph DB)**          | Хранение онтологии и связей                     | Подграф/пути, k-hop расширения                             |
| **FAISS (Vector store)**      | Сохранение векторного индекса                   | Быстрый первичный поиск релевантных чанков                 |
| **OpenAI Embeddings**         | Построение эмбеддингов                          | — (если генерация ответа — можно тем же провайдером)       |
| **LLM (ответ)**               | —                                               | Генерация ответа строго из контекста                       |

---

## Мини-чеклист UX (оба сценария)

* Ясные состояния: `PENDING`, `RUNNING`, `DONE`, `ERROR` — одинаково в GUI и API.
* Номер задачи (`job_id`) кликабелен → детальная панель: логи/ошибки/метрики.
* В Q&A первая строка ответа — однофразный вывод, далее короткое объяснение (1–2 предложения).
* Цитаты — максимум 5; каждая с сниппетом (3–5 строк) и путём к файлу.
* Пути графа — не «километр», а 1–3 наиболее коротких/информативных, с типами рёбер.
* Ошибки — человеческим языком (не стек-трейс).

если хочешь, на следующем шаге отдам «скелет» фронтовых страниц `/upload` и `/qa` (Next.js) и минимальные FastAPI-роуты именно под эти сценарии (чтобы ты сразу поднял и прошёлся по шагам).
---

# Мини-гайд: GraphView с кластеризацией по файлам

- Как включить:
  - Откройте /graphview, задайте Collection/Limit (и Rels при необходимости).
  - Для client‑режима укажите Seeds; для server — тоже обязательно.
  - Отметьте чекбокс "Cluster by file (path)" и нажмите Load (опция применяется при перезагрузке).
- Что делает:
  - На каждый уникальный path добавляет File‑узел (id: file::<full_path>, label: "File", title: полный путь).
  - Каждому исходному узлу с path добавляет связь IN_FILE к соответствующему File‑узлу.
  - Силовая модель настраивается так, чтобы узлы с одинаковым path «собирались» в компактный кластер.
- Ограничения:
  - Узлы без path не кластеризуются.
  - Количество элементов увеличивается за счёт File‑нод и IN_FILE связей.
  - Применяется на загрузке; после изменения чекбокса нажмите Load.
- Параметры сил:
  - IN_FILE: distance ≈ 14, strength ≈ 1.0.
  - Прочие связи: distance ≈ 60, strength ≈ 0.15.
